// Liquid Glass runtime shader, адаптированный под SkiaSharp 2.88
// Основная идея: мягкое размытие фона + лёгкое преломление и цветовое искажение
// для имитации "жидкого стекла" без использования недоступных функций Skia.

uniform float2 resolution;              // размер области в пикселях
uniform float displacementScale;        // интенсивность волновой деформации [0..100]
uniform float blurAmount;               // дополнительное размытие [0..1]
uniform float saturation;               // множитель насыщенности (0..2)
uniform float aberrationIntensity;      // сила цветового смещения [0..10]
uniform float cornerRadius;             // информация о радиусе скругления (не используется в шейдере)
uniform float2 mouseOffset;             // смещение курсора (не используется, зарезервировано)
uniform float2 globalMouse;             // глобальные координаты курсора (не используется)
uniform float isHovered;                // флаг наведения
uniform float isActive;                 // флаг активности
uniform float overLight;                // индикатор светлого фона
uniform float edgeMaskOffset;           // резерв
uniform float3 chromaticAberrationScales; // индивидуальный множитель по каналам
uniform float hasDisplacementMap;       // признак наличия карты смещения (0 или 1)

uniform shader backgroundTexture;       // снимок текущего содержимого поверх которого рисуем
uniform shader displacementTexture;     // карта смещения (необязательна)

// ---- Вспомогательные функции ------------------------------------------------

float smoothstep_local(float edge0, float edge1, float x)
{
    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

half4 sample_background(float2 uv)
{
    float2 clamped = clamp(uv, float2(0.0, 0.0), float2(1.0, 1.0));
    return sample(backgroundTexture, clamped * resolution);
}

half2 read_displacement(float2 uv)
{
    if (hasDisplacementMap < 0.5)
    {
        return half2(0.0, 0.0);
    }

    float2 clamped = clamp(uv, float2(0.0, 0.0), float2(1.0, 1.0));
    half4 disp = sample(displacementTexture, clamped * resolution);

    // перевод из [0,1] в [-1,1]
    return half2(disp.rg * 2.0 - 1.0);
}

half4 adjust_saturation(half4 color, float multiplier)
{
    half3 weights = half3(0.299, 0.587, 0.114);
    half luminance = dot(color.rgb, weights);
    half3 grey = half3(luminance, luminance, luminance);
    return half4(mix(grey, color.rgb, half(multiplier)), color.a);
}

// Простая имитация искажений жидкости: лёгкая радиальная волна + карта смещения
float2 distort_uv(float2 uv, float strength)
{
    float2 centered = uv - 0.5;
    float dist = length(centered);

    // радиальная волна
    float wave = sin(dist * 12.0 + strength * 4.0) * 0.003 * strength;

    float2 dir = dist > 0.0001 ? centered / dist : float2(0.0, 0.0);
    float2 radialOffset = dir * wave;

    // карта смещения
    half2 disp = read_displacement(uv) * half(strength * 0.03);

    return uv + radialOffset + float2(disp);
}

half4 apply_chromatic_aberration(float2 uv, float strength)
{
    float baseStrength = strength * 0.0025;

    float2 rUV = distort_uv(uv + float2(baseStrength * chromaticAberrationScales.r, 0.0), strength);
    float2 gUV = distort_uv(uv, strength);
    float2 bUV = distort_uv(uv - float2(baseStrength * chromaticAberrationScales.b, 0.0), strength);

    half4 r = sample_background(rUV);
    half4 g = sample_background(gUV);
    half4 b = sample_background(bUV);

    return half4(r.r, g.g, b.b, g.a);
}

half4 apply_interaction_lighting(float2 uv, half4 color)
{
    if (isHovered > 0.5)
    {
        float2 center = float2(0.5, 0.0);
        float dist = length(uv - center);
        float mask = smoothstep_local(0.6, 0.0, dist);
        color.rgb += half3(0.18, 0.2, 0.25) * half(mask);
    }

    if (isActive > 0.5)
    {
        float2 center = float2(0.5, 0.1);
        float dist = length(uv - center);
        float mask = smoothstep_local(0.8, 0.0, dist);
        color.rgb += half3(0.12, 0.16, 0.25) * half(mask);
    }

    return color;
}

// Имитация дополнительного размытия за счёт усреднения нескольких сэмплов
half4 apply_soft_blur(float2 uv, float blurStrength)
{
    if (blurStrength < 0.01)
    {
        return sample_background(uv);
    }

    float radius = blurStrength * 0.012;
    float2 offsets[4] = float2[4](
        float2( radius,  radius),
        float2(-radius,  radius),
        float2( radius, -radius),
        float2(-radius, -radius)
    );

    half4 acc = half4(0.0);
    for (int i = 0; i < 4; ++i)
    {
        acc += sample_background(uv + offsets[i]);
    }

    return acc * 0.25;
}

// ---- Основная функция -------------------------------------------------------

half4 main(float2 coord)
{
    float2 uv = coord / resolution;

    float displacementStrength = clamp(displacementScale / 100.0, 0.0, 1.5);
    float aberrationStrength = clamp(aberrationIntensity, 0.0, 10.0);

    half4 baseColor = apply_soft_blur(uv, blurAmount);
    half4 liquidColor = apply_chromatic_aberration(distort_uv(uv, displacementStrength), aberrationStrength);

    // Смешиваем размытие и жидкое искажение
    half4 color = mix(baseColor, liquidColor, half(0.65));

    color = adjust_saturation(color, saturation);
    color = apply_interaction_lighting(uv, color);

    if (overLight > 0.5)
    {
        color.rgb *= half3(0.85, 0.85, 0.9);
    }

    color.a = 1.0;
    return color;
}
